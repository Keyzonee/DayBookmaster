/*
 * This file was last modified at 2022.03.23 22:47 by Victor N. Skurikhin.
 * This is free and unencumbered software released into the public domain.
 * For more information, please refer to <http://unlicense.org>
 * build.gradle
 * $Id$
 */

import java.util.regex.Matcher
import java.util.regex.Pattern
import org.apache.tools.ant.filters.ReplaceTokens

//file:noinspection GradlePackageUpdate

plugins {
    id 'io.quarkus'
    id 'java'
    id 'org.liquibase.gradle' version '2.0.4'
}

repositories {
    mavenCentral()
    mavenLocal()
}

ext.libVers = [
        drv_org_postgresql     : getEnv('VERSION_DRV_ORG_POSTGRESQL', VERSION_DRV_ORG_POSTGRESQL),
        liquibase              : getEnv('VERSION_ORG_LIQUIBASE', VERSION_ORG_LIQUIBASE),
        liquibase_gradle_plugin: getEnv('VERSION_LIQUIBASE_GRADLE_PLUGIN', VERSION_LIQUIBASE_GRADLE_PLUGIN),
        netty_transport_native : getEnv('VERSION_NETTY_TRANSPORT_NATIVE', VERSION_NETTY_TRANSPORT_NATIVE),
        slf4j                  : getEnv('VERSION_ORG_SLF4J_VERSION', VERSION_ORG_SLF4J_VERSION),
        embedded_postgres      : '2.0.2',
        equalsverifier         : '3.12.3',
        google_collections     : '1.0',
        jsr305                 : '3.0.2',
        mockito_core           : '3.2.4',
]

dependencies {
    implementation "io.quarkus:quarkus-resteasy-reactive"
    implementation "io.quarkus:quarkus-resteasy-reactive-jackson"
    implementation "io.quarkus:quarkus-reactive-pg-client"
    implementation "io.quarkus:quarkus-vertx"
    implementation enforcedPlatform("${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}")
    implementation "io.quarkus:quarkus-arc"
    implementation "io.netty:netty-transport-native-epoll:$libVers.netty_transport_native:linux-x86_64"
    implementation "io.netty:netty-transport-native-kqueue:$libVers.netty_transport_native:osx-x86_64"
    implementation "com.google.code.findbugs:jsr305:$libVers.jsr305"
    implementation "com.google.collections:google-collections:$libVers.google_collections"

    liquibaseRuntime group: 'org.slf4j', name: 'slf4j-api', version: libVers.slf4j
    liquibaseRuntime group: 'org.slf4j', name: 'slf4j-simple', version: libVers.slf4j
    liquibaseRuntime group: 'org.liquibase', name: 'liquibase-core', version: libVers.liquibase
    liquibaseRuntime group: 'org.liquibase', name: 'liquibase-gradle-plugin', version: libVers.liquibase_gradle_plugin
    liquibaseRuntime group: 'org.postgresql', name: 'postgresql', version: libVers.drv_org_postgresql

    testImplementation "io.quarkus:quarkus-junit5"
    testImplementation "io.rest-assured:rest-assured"
    testImplementation "io.zonky.test:embedded-postgres:$libVers.embedded_postgres"
    testImplementation "nl.jqno.equalsverifier:equalsverifier:$libVers.equalsverifier"
    testImplementation "org.liquibase:liquibase-core:$libVers.liquibase"
    testImplementation "org.mockito:mockito-core:$libVers.mockito_core"
}

def schemaName = 'db'
def db_url = getEnv('DBURL', DATABASE_URL)
def db_username = getEnv('DBUSER', DATABASE_USERNAME)
def db_password = getEnv('DBPASS', DATABASE_PASSWORD)
def db_url_public = db_url + '?currentSchema=public'
def run_list = project.properties['runList'] ?: 'db'
def projectDir = project.projectDir.toString()
def resourcesDb = 'src/main/resources/db'
def resourcesDbPath = "${projectDir}/${resourcesDb}"
def dbMigrationResourcesDbPath = "./${resourcesDb}"

liquibase {
    activities {
        db {
            changeLogFile "${dbMigrationResourcesDbPath}/changelog/db/Change-Log.xml"
            url db_url_public
            defaultSchemaName 'public'
            username db_username
            password db_password
            classpath "$rootDir"
        }
    }
    runList = run_list
}

group 'su.svn'
version '3.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

compileJava {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-parameters'
}

compileTestJava {
    options.encoding = 'UTF-8'
}

quarkusBuild {
    nativeArgs {
        containerBuild = true
        buildImage = "quay.io/quarkus/ubi-quarkus-native-image:21.3.0-java11"
    }
}

test {
    useJUnitPlatform()
    environment "LC_CTYPE", "en_US.UTF-8"
    environment "LC_ALL", "en_US.UTF-8"
}

static def getEnv(key, defaultValue) {
    return System.getenv(key) ?: defaultValue
}

static String toCamelCase(String text, boolean capitalized = false) {
    text = text.replaceAll("(_)([A-Za-z0-9])", { Object[] it -> it[2].toUpperCase() })
    return capitalized ? text.capitalize() : text
}

static String toSnakeCase(String text) {
    text.replaceAll(/([A-Z])/, /_$1/).toLowerCase().replaceAll(/^_/, '')
}

static String getLastVersion(String content) {
    String regex = "--changeset[\\s]+[^\\s]+:(\\d+)"
    Matcher matcher = Pattern.compile(regex).matcher(content)

    while (matcher.find()) {
        return Integer.valueOf(matcher.group(1)) + 4
    }
    return "1"
}

// номер changeset всегда должен быть уникальным!!!
static def getLastVersionFile(String folder) {
    def files = new File(folder).listFiles()?.sort { it.getName() }
    def file = files.size() > 0 ? files?.last() : null
    if (Objects.isNull(file)) {
        return "1"
    }
    String fileContents = file.getText('UTF-8')
    return getLastVersion(fileContents)
}

static String getChangeSetFileName(String scriptName, String version) {
    def date = new Date()
    def formattedDate = date.format("yyyy_MM_dd")
    def formattedTime = date.format("HH_mm_ss")
    return "${version}_date_${formattedDate}_time_${formattedTime}_${scriptName}.sql"
}

static String getChangeSetFolderPath(String resourcesDbPath, String dbName) { return "${resourcesDbPath}/changelog/${dbName}/Change-Sets" }

def getProjectProperty(key, defaultValue) {
    return project.getProperties().get(key) ?: defaultValue
}

private void genDictionary(template, projectDir, to, sufix = "") {
    def templateFileName = template.toPath().fileName.toString()
    def name = this.getProjectProperty('table', 'value_type').toString()
    def schema = this.getProjectProperty('schema', 'dictionary').toString()
    def idType = this.getProjectProperty('IdType', 'Long').toString()
    def key = this.getProjectProperty('key', 'key').toString()
    def keyType = this.getProjectProperty('keyType', 'String').toString()
    def value = this.getProjectProperty('value', 'value').toString()
    def valueType = this.getProjectProperty('valueType', 'String').toString()
    def uuid = UUID.randomUUID().toString()
    copy {
        from template
        filter ReplaceTokens, tokens: [
                serialVersionUID: new Random().nextLong().toString(),
                schema          : schema,
                SCHEMA          : schema.toUpperCase(),
                Name            : toCamelCase(name, true),
                table           : name,
                TABLE           : name.toUpperCase(),
                IdType          : idType,
                key             : key,
                Key             : key.capitalize(),
                KType           : keyType,
                value           : value,
                Value           : value.capitalize(),
                VType           : valueType,
                uuid            : uuid
        ]
        into projectDir + '/' + to
        rename { filename ->
            filename.replace templateFileName, toCamelCase(name, true) + sufix + '.java'
        }
    }
}

private void genSql(File template, resourcesDb, resourcesDbPath, dbName, prefix = 'create') {
    def templateFileName = template.toPath().fileName.toString()
    def task = this.getProjectProperty('task', 'issue_1')
    def name = this.getProjectProperty('table', 'value_type').toString()
    def schema = this.getProjectProperty('schema', 'dictionary').toString()

    def desc = prefix + '_' + name
    def scriptName = "${task}_${desc}"
    def folderPath = getChangeSetFolderPath(resourcesDbPath, dbName)
    def version = getLastVersionFile(folderPath + "/")
    def fileName = getChangeSetFileName(scriptName, version)
    def logicalFilePath = "${resourcesDb}/changelog/${dbName}/Change-Sets/${fileName}"

    def changeSetAuthor = java.util.Optional
            .ofNullable(System.getProperty("username"))
            .orElse(System.getenv("USER"))

    copy {
        from template
        filter ReplaceTokens, tokens: [
                schema          : schema,
                table           : name,
                key             : 'key',
                value           : 'value',
                version         : version,
                rnd             : (1000 + new Random().nextInt(8999)).toString(),
                logicalFilePath : logicalFilePath.toString(),
                changeSetAuthor : changeSetAuthor
        ]
        into folderPath
        rename { filename ->
            filename.replace templateFileName, fileName
        }
    }
}

task generator() {
    def model = new File("src/templates/Dictionary.java")
    def dao = new File("src/templates/DictionaryDao.java")
    def service = new File("src/templates/DictionaryService.java")
    def resource = new File("src/templates/DictionaryResource.java")
    def test = new File("src/templates/DictionaryTest.java")
    def createTable = new File("src/templates/create_table.sql")
    def tableTriggers = new File("src/templates/table_triggers.sql")
    doLast {
        genDictionary(model, projectDir, "src/main/java/su/svn/daybook/domain/model")
        genDictionary(dao, projectDir, "src/main/java/su/svn/daybook/domain/dao", "Dao")
        genDictionary(resource, projectDir, "src/main/java/su/svn/daybook/resources", "Resource")
        genDictionary(service, projectDir, "src/main/java/su/svn/daybook/services", "Service")
        genDictionary(test, projectDir, "src/test/java/su/svn/daybook/domain/model", "Test")
        genSql(createTable, resourcesDb, resourcesDbPath, schemaName)
        genSql(tableTriggers, resourcesDb, resourcesDbPath, schemaName, 'triggers')
    }
}

task generate() {
    doLast {
        def task = this.getProjectProperty('task', 'issue_1')
        def desc = this.getProjectProperty('desc', 'migration')
        def scriptName = "${task}_${desc}"
        def version = getLastVersionFile(folderPath + "/")

        def folderPath = getChangeSetFolderPath(resourcesDbPath, schemaName)
        def fileName = getChangeSetFileName(scriptName, version)
        def filePath = "${folderPath}/${fileName}"
        def logicalFilePath = "${resourcesDb}/changelog/${schemaName}/Change-Sets/${fileName}"

        def changeSetAuthor = java.util.Optional
                .ofNullable(System.getProperty("username"))
                .orElse(System.getenv("USER"))

        List<String> sample = [
                '--liquibase formatted sql', '--', '', '--',
                "--changeset ${changeSetAuthor}:${version} endDelimiter:; failOnError:true logicalFilePath:${logicalFilePath}",
                '--', '', '--',
                '-- << COMMAND HERE >>', '--', '',
                '--', '--rollback',
                ''] as String[]
        // create the file and write text to it.
        def file = new File(filePath)
        file.text = sample.join("\n")
        println "File created ${file.getAbsolutePath()}"
    }
}
